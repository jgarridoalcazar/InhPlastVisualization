#include <string.h>
#include <stdlib.h>
#include <time.h>
#include "uegoconf.h"
#include "uego.h"

// ------------------------------------------------------------------------


Ini::Ini( FILE* stream ) {
// we assume here that the ini file is correct, so don't do value
// checks and that stuff. it should be generated by setup afterall...

	char	*buff;
	double last_r;
	double	sqrsum;
	double	beta;
	double		evals1; // double to handle negative numbers
	unsigned long	evals2;





	FailFlag = 1==0;	// it is ok here


	//------------------------------------------
	//---Parallel variables---------------------
	//------------------------------------------	
	if(MPI_Comm_rank(MPI_COMM_WORLD,&myid)!=MPI_SUCCESS) 		
		printf("An error in: Ini::INI --> MPI_Comm_Rank\n");
	
	if (MPI_Comm_size(MPI_COMM_WORLD,&numproc)!=MPI_SUCCESS)	
		printf("An error in: Ini::INI --> MPI_Comm_size\n");
	
	putmyidIni(myid); 
	putnumprocIni(numproc);
	
	//-----



	prototype = NULL;		// SetPrototype allocates memory
	param = r = lowb = upb = NULL;	// GetVector allocates
	evals = newspecevals = NULL;	//		memory

	if( !ToBuffer( stream, &buff ) )
	{
		FailFlag = 1==1;
		return;
	}

	// --- random numbers -------------------------------------------
	seed=time(NULL);
	// --- objective function ---------------------------------------
	type = 0;      // Search spece= real domain 
	dimension = (long) GetValue( buff, (char*)DIM_T );
	if( Fail() )
	{
		delete buff;
		return;
	};
	// --- uego parameters -------------------------------------------
	maxevals = (unsigned long) GetValue( buff, (char*)MAXEV_T);
	maxspecnum = (long) GetValue( buff, (char*)MAXSPEC_T );
	levels = (long) GetValue( buff, (char*)LEVELS_T );
  	last_r = (double)GetValue( buff, (char*)RADII_T );
	if( Fail() )
	{
		last_r = 0;
		FailFlag = 1==0;
	}

	
	// --- loading vectors ---------------------------------------------
	if( !Fail() && BOUND_NEEDED( type ) )
	{
		FailFlag =
		!GetVector( buff, (char*)LOWB_T, &lowb, NULL, dimension ) ||
		!GetVector( buff, (char*)UPB_T, &upb, NULL, dimension );
	};


	//---
	paramNames=(char**)malloc(dimension*sizeof(char*));
	for(int i=0;i<dimension;i++) paramNames[i]=new char[102];

	// ---Name of the parameters to be optimized-----------------
	paramNames=GetNames(buff,(char*)PARAM_NAMES,dimension);
	
	//for(int i=0;i<dimension;i++) printf(" %s ", paramNames[i]);
	//getchar();

	// --------------------------------------------------------
        // -----------------RADIUS CALCULATION---------------------
        // --------------------------------------------------------
        // --------------------------------------------------------

	sqrsum = 0.0;
	r= new double[levels];
    


	for( long i=dimension/3; i < dimension; ++i )
	{
		sqrsum += (lowb[i] - upb[i] ) *
				( lowb[i] - upb[i] );
	};

	r[0]=sqrt( sqrsum ); 
	
	// --- calculate exponential factor for radii -------------
	beta = pow( (last_r / r[0]), 1.0/(levels-1) );

	// --- calculate radii ------------------------------------
	for( long i=1; i < levels; ++i )
		r[i] = r[i-1] * beta;

	// --------------------------------------------------------
        // -----------------EVALS FOR CREATION---------------------
        // --------------------------------------------------------
        // --------------------------------------------------------

	evals = new unsigned long[ levels ];
	newspecevals = new unsigned long[ levels - 1 ];
	
	for( int i=1; i < levels; ++i )
		newspecevals[i-1] = 3 * maxspecnum;


	// --------------------------------------------------------
        // -----------------EVALS FOR OPTIMIZATION-----------------
        // --------------------------------------------------------
        // --------------------------------------------------------

	evals1 = maxevals;

	for( int i=1; i < levels; ++i ) evals1 -= newspecevals[i-1];
	if( evals1 < 0 )
	{
		message((char*)"All evaluations (N) too small, parameters not set.",
								MSG_ERROR);
		FailFlag = 1==1;
		return;
	};

	//---initial threshold
	threshold = 1.0;
	//---initial number of function evaluation for optimization process
	for(int  i=1; i < levels; ++i )
	   evals[i] = (unsigned long) (
			maxspecnum * r[0] *
				threshold /v(r[i]) );


	//---threashold calculation
	evals2 = 0;
	for( int i=0; i < levels; ++i ) evals2 += evals[i];
        //printf(" Evals2= %ld", evals2);
	threshold = evals1 / (double)evals2;

	//---Calculate the number of function evaluation for optimization process	
	for(int  i=1; i < levels; ++i ){
		evals[i] = (unsigned long) (
			maxspecnum * r[0] *threshold /v( r[i] ) );
	}
        
	
         /*printf("\n function evaluations in new species: \n");        
	 for(int i=0;i< levels-1;i++) printf("%ld ", newspecevals[i]);
	 printf("\n");

	
        printf("\n evaluations for levels: \n");        
	for(int i=0;i< levels;i++) printf("%ld ", evals[i]);
	printf("\n");

  
	printf("\n radii for levels: \n ");	
	for( int i=0; i<levels;i++)
		printf("%e ",r[i]);
	printf("\n");*/



	
	delete buff;

	if( !Fail() ) SetPrototype();

	if( FailFlag ) message((char*) "Failed loading ini file.",MSG_ERROR);

};


// ------------------------------------------------------------------------

double	Ini::v( double r ) {
#define SPEED_CONSTANTS 14
//  Using that binom(x,(x-1)/2)==.5*binom(x+1,(x+1)/2) and
//  binom(2n,n) is approx. 2**(2n)/sqrt(pi*n)

	double	V[ SPEED_CONSTANTS ] = {	// for r==1.0
		0.0,			.25,
		M_2_PI / 3.0,		3.0 / 16.0,
		4 * M_2_PI / 15.0,	10.0 / 64.0,
		8 * M_2_PI / 35.0,	35.0 / 256.0,
		64 * M_2_PI / 315.0,	63.0 / 512.0,
		128 * M_2_PI / 693.0,	231.0 / 2048.0,
		512 * M_2_PI / 3003.0,	858.0 / 8192.0  };

	if( dimension < SPEED_CONSTANTS ) return V[dimension] * r;
	else return r / sqrt( M_PI * (2 * (dimension+1)) );

#undef SPEED_CONSTANTS
};


// ------------------------------------------------------------------------


Ini::Ini() {

	FailFlag = 1==1;

	prototype = NULL; 	// SetPrototype allocates memory
	param = r = lowb = upb = NULL;
	evals = newspecevals = NULL;

	// --- random numbers
	//seed = 123456789;
	seed=time(NULL);

	// --- objective function
	type = NDIMREAL_TYPE;
	fnum = 6;
	dimension = 1;
	paramnum = 0;
	param = NULL;
	lowb = new double[1];
	upb = new double[1];
	if( lowb == NULL || upb == NULL )
	{
		message((char*)"No memory in ini constructor.",MSG_ERROR);
		return;
	};
	lowb[0] = 0.0;
	upb[0] = 10.0;

	// --- uego parameters
	maxevals = 20000;
	maxspecnum = 50;
	threshold = 1.0;
	levels = 3;
	newspecevals = new unsigned long[ levels-1 ];
	r = new double[ levels ];
	evals = new unsigned long[ levels ];
	if( evals == NULL || newspecevals == NULL || r == NULL )
	{
		message((char*)"No memory in ini constructor.",MSG_ERROR);
		return;
	};
	newspecevals[0] = 300; newspecevals[1] = 300;
	r[0] = 10; r[1] = 1.5; r[2] = .2;
	evals[0] = 0; evals[1] = 657; evals[2] = 18743;

	SetPrototype();
	// FailFlag is set properly!
};


// ------------------------------------------------------------------------


Ini::~Ini() {

	if( param != NULL ) delete param;
	if( r != NULL ) delete r;
	if( lowb != NULL ) delete lowb;
	if( upb != NULL ) delete upb;
	if( evals != NULL ) delete evals;
	if( newspecevals != NULL ) delete newspecevals;
	if( prototype != NULL ) delete prototype;
};


// ------------------------------------------------------------------------


void	Ini::SetPrototype() {

	FailFlag = 1==1;

	if( prototype != NULL ) delete prototype;
	switch( type )
	{
		case NDIMREAL_TYPE:
			prototype = new NDimRealElement( dimension );
			break;
		case BINARY_TYPE:
			prototype = new BinaryElement( dimension );
			break;
	};

	if( prototype->Fail() || prototype == NULL )
	{
		message((char*)"Error setting prototype.",MSG_ERROR);
		return;
	};

	FailFlag = 1==0;
};


// ------------------------------------------------------------------------


void	Ini::Save( FILE* stream ) {

	long	i;

	FailFlag = fprintf( stream, INI_OUT_HEADER ) == EOF ||

	// --- random numbers -------------------------------------------
	fprintf( stream, "\n[Random numbers]\n\n" ) == EOF ||
	fprintf( stream, "\t%s\t%lu\n", SEED_T, seed ) == EOF ||

	// --- objective function ---------------------------------------
	fprintf( stream, "\n[Objective function]\n\n" ) == EOF ||
	fprintf( stream, "\t%s\t%ld\n\t%s\t\t%ld\n\t%s\t%ld\n",
		TYPE_T, (long)type,
		FNUM_T, (long)fnum,
		DIM_T, (long)dimension ) == EOF;

	// --- saving lower and upper bounds if any
	FailFlag = FailFlag ||
	!SaveVector( stream, (char*)LOWB_T, lowb, NULL, dimension ) ||
	!SaveVector( stream, (char*)UPB_T, upb, NULL, dimension );

	// --- saving constant parameters if any
	if( !FailFlag && paramnum != 0 )
	{
		FailFlag = fprintf( stream, "\t%s\t%ld\n",
				PARNUM_T, (long)paramnum ) == EOF ||
		!SaveVector( stream, (char*)PAR_T, param, NULL, paramnum );
	};

	// --- uego parameters ------------------------------------------
	FailFlag = FailFlag ||
	fprintf( stream, "\n[UEGO parameters]\n\n" ) == EOF ||
	fprintf( stream, "\t%s\t%lu\n\t%s\t%ld\n\t%s\t%lg\n\t%s\t\t\t%ld\n",
		MAXEV_T, maxevals,
		MAXSPEC_T, (long)maxspecnum,
		THR_T, threshold,
		LEVELS_T, (long)levels ) == EOF;

	FailFlag = FailFlag ||
	!SaveVector( stream, (char*)NEWSPEV_T, NULL, newspecevals, levels-1 ) ||
	!SaveVector( stream, (char*)EVALS_T, NULL, evals, levels ) ||
	!SaveVector( stream, (char*)RADII_T, r, NULL, levels );

	if( FailFlag ) message( (char*)"Failed writing ini file.",MSG_ERROR);
};


// ------------------------------------------------------------------------


char	Ini::SaveVector( FILE* stream, char* name, double* d, unsigned long* ul, long length ) {
// static member
// purpose: saves 'name', and after name saves 'length'
//	doubles if d != NULL otherwise 'length' unsigned longs.
//	the values are saved from 'd' or 'ul' accordingly.
//      the values are separated by whitespace (including new lines) only
// returns true if success, false if not

	char	FailFlag, IsDouble = d != NULL;
	long	i;

	if( length == 0 || (d == NULL && ul == NULL) ) return 1==1;
	FailFlag = fprintf( stream, "\t%s", name ) == EOF;
	for( i=0; !FailFlag && i<length; ++i )
	{
		if( i%6 == 0 ) FailFlag = fprintf( stream, "\n\t\t" ) == EOF;
		if( !FailFlag && IsDouble )
			if( fabs( d[i] ) < 1.0 )
				FailFlag=fprintf( stream, "%le ", d[i]) == EOF;
			else
				FailFlag=fprintf( stream, "%lf ", d[i]) == EOF;
		else
			FailFlag = fprintf( stream, "%lu ", ul[i] ) == EOF;
	};
	FailFlag = FailFlag || fprintf( stream, "\n" ) == EOF;
	return !FailFlag;
};


// ------------------------------------------------------------------------


char	Ini::ToBuffer( FILE* stream, char** buff ) {
// static member
// purpose:
//	load 'stream' to '*buff'. Also performs memory allocation according
//	to size of input file. performs no formatting
// returns true if success, false if not

	long	i, length = 0;

	// --- read test
	if( fseek( stream, 0, SEEK_SET ) != 0 )
	{
		message((char*)"Cannot read ini file.",MSG_ERROR);
		return 1==0;
	};

	// --- allocate memory
	for( fgetc( stream ); !feof(stream); fgetc( stream ) ) ++length;
	if( length == 0 )
	{
		buff = NULL;
		message((char*)"Zero length ini file.",MSG_ERROR);
		return 1==0;
	};
	if( (*buff = new char[length]) == NULL )
	{
		message((char*)"No memory for loading ini file.",MSG_ERROR);
		return 1==0;
	};

	// --- read ini file
	// (fgetc must be used because of DOS)
	rewind( stream );
	for(i=0; !feof(stream) && i<length; ++i )
		(*buff)[i] = (char)fgetc(stream);

	return 1==1;
};


// ------------------------------------------------------------------------


char	Ini::GetVector( char* buff, char* name, double** d, unsigned long** ul, long length ) {
// static member
// purpose: finds 'name' in buff, and after name tries to read 'length'
//	doubles if d != NULL otherwise 'length' unsigned longs.
//	the values are saved to *d or *ul accordingly.
//      the values must be separated by whitespace only
//	performs memory allocation too.
// returns true if success, false if not

	char	FailFlag, IsDouble = d != NULL,
		*pos, msg[100], white[15] = " \n\v\b\r\f\t";
	long	i;
	double	db;

	if( length == 0 || (d == NULL && ul == NULL) ) return 1==1;
	FailFlag = 1==1;

	// --- find token in ini file -------------------------------------
	if( (pos = strstr( buff, name )) == NULL )
	{
		sprintf( msg, "Could not find '%s' in ini file", name );
		message( msg, MSG_INFORMATION );
		return !FailFlag;
	};
	pos += strlen(name); // position after the token

	// --- allocate memory --------------------------------------------
	if( IsDouble ) (*d) = new double[length];
	else (*ul) = new unsigned long[length];
	if( (IsDouble && *d == NULL) || (!IsDouble && *ul == NULL ))
	{
		message((char*)"No memory while loading ini file.",MSG_ERROR);
		return !FailFlag;
	};

	// --- read data --------------------------------------------------
	FailFlag = 1==0;
	for( i=0; i<length && !FailFlag; ++i )
	{
		pos += strspn( pos, white ); // skip leading whitespace
		FailFlag = FailFlag || sscanf( pos, "%lf ", &db ) != 1;
		if( IsDouble ) (*d)[i] = db;
		else (*ul)[i] = (unsigned long) db;
		pos = strpbrk( pos, white ); // skip number just read
		if( pos == NULL ) FailFlag = 1==1;
	};

	if( FailFlag )
	{
		sprintf( msg, "Failed loading '%s' from ini file", name );
		message( msg, MSG_ERROR );
	};

	return !FailFlag;
};


// ------------------------------------------------------------------------


double	Ini::GetValue( char* buff, char* name ) {
// could be static but it's more natural to use
// FailFlag here than something else to inidicate error

	double	*d, result;

	d = NULL;
	FailFlag = FailFlag || !GetVector( buff, name, &d, NULL, 1 );

	if( !Fail() ) result = d[0];
	else result = 0.0;
	if( d != NULL ) delete d;

	return result;
};

// ------------------------------------------------------------------------


char ** Ini::GetNames( char* buff, char* name,long length) {
// static member
// purpose: finds 'name' in buff, and after name tries to read 'length'
//	char* if d != NULL.
//	the values are saved to *d.
//      the values must be separated by whitespace only
//	performs memory allocation too.
// returns true if success, false if not

	char	FailFlag,
		*pos, msg[100], white[15] = " \n\v\b\r\f\t";
	long	i;
	char	db[102];
	FILE *fpoii;
	char **d;

	FailFlag = 1==1;

	// --- find token in ini file -------------------------------------
	if( (pos = strstr( buff, name )) == NULL )
	{
		sprintf( msg, (char*)"Could not find '%s' in ini file", name );
		message( msg, MSG_INFORMATION );
	};
	pos += strlen(name); // position after the token
	
	// --- Allocations memory
		d=(char**)malloc(dimension*sizeof(char*));
	for(int i=0;i<dimension;i++) d[i]=new char[102];


	// --- read data --------------------------------------------------
	FailFlag = 1==0;
	pos += strspn( pos, white ); // skip leading whitespace

	for(long i=0 ; i< dimension;i++){
		FailFlag = FailFlag || sscanf( pos, "%s ", db ) != 1;
		if( FailFlag )
			sprintf( msg, (char*)"Failed loading name of parameter");
		
		strcpy(d[i],db);
		pos += strlen(db);
		pos += strspn( pos, white ); // skip leading whitespace
	}

	FailFlag = 1==1;
	return d;
};
